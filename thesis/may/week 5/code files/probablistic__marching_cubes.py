# -*- coding: utf-8 -*-
"""PROBABLISTIC _MARCHING-CUBES.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vXp2n5ARK1Q4KYoWqaSycywKA8VT3Ye3
"""

import numpy as np
import vtk
from vtk.util.numpy_support import vtk_to_numpy, numpy_to_vtk
from tqdm import tqdm
# === CONFIG ===
INPUT_VTI = "isabel_gaussian.vti"   # Your input file
MEAN_NAME = "mean"                       # Name of mean scalar field
VAR_NAME = "variance"                    # Name of variance scalar field
ISOLEVEL = -1168.284423828125                           # Isovalue to evaluate
N_SAMPLES = 1000                         # Monte Carlo samples
OUTPUT_VTI = "probabilistic_marching_cubes.vti"

# === Load the VTI File ===
reader = vtk.vtkXMLImageDataReader()
reader.SetFileName(INPUT_VTI)
reader.Update()
image = reader.GetOutput()
dims = image.GetDimensions()

mean_arr = vtk_to_numpy(image.GetPointData().GetArray(0))
var_arr = vtk_to_numpy(image.GetPointData().GetArray(1))

mean_3d = mean_arr.reshape(dims[::-1])
var_3d = var_arr.reshape(dims[::-1])
std_3d = np.sqrt(var_3d)

# === Monte Carlo Probability Estimation ===

def get_cell_vertices(i, j, k):
    return [
        (i,   j,   k),
        (i+1, j,   k),
        (i+1, j+1, k),
        (i,   j+1, k),
        (i,   j,   k+1),
        (i+1, j,   k+1),
        (i+1, j+1, k+1),
        (i,   j+1, k+1),
    ]

def sample_crossing_probability(mu, sigma, isovalue, n_samples):
    count = 0
    for _ in range(n_samples):
        y = mu + sigma * np.random.randn(8)
        if np.min(y) < isovalue and np.max(y) > isovalue:
            count += 1
    return count / n_samples

# Probabilities are stored per cell center (one less in each dimension)
output_shape = tuple(d - 1 for d in mean_3d.shape)
prob_grid = np.zeros(output_shape, dtype=np.float32)

total_cells = output_shape[0] * output_shape[1] * output_shape[2]
progress = tqdm(total=total_cells, desc="Processing Cells")

print("Computing probabilities...")
for i in range(output_shape[0]):
    for j in range(output_shape[1]):
        for k in range(output_shape[2]):
            verts = get_cell_vertices(i, j, k)
            mu = np.array([mean_3d[x, y, z] for (x, y, z) in verts])
            sigma = np.array([std_3d[x, y, z] for (x, y, z) in verts])
            prob = sample_crossing_probability(mu, sigma, ISOLEVEL, N_SAMPLES)
            prob_grid[i, j, k] = prob
            progress.update(1)

progress.close()

# === Convert to VTK ImageData ===
prob_image = vtk.vtkImageData()
prob_image.SetDimensions(prob_grid.shape)
prob_image.SetSpacing(image.GetSpacing())
prob_image.SetOrigin(image.GetOrigin())

flat = prob_grid.ravel(order='F')  # VTK expects Fortran order
vtk_array = numpy_to_vtk(flat, deep=True)
vtk_array.SetName("crossing_probability")
prob_image.GetPointData().AddArray(vtk_array)
prob_image.GetPointData().SetActiveScalars("crossing_probability")

# === Write Output ===
writer = vtk.vtkXMLImageDataWriter()
writer.SetFileName(OUTPUT_VTI)
writer.SetInputData(prob_image)
writer.Write()

print(f"Saved output to {OUTPUT_VTI}")